@page "/"
@using System.ComponentModel

@inject IChatClient ChatClient
@inject OpenWeatherClient OpenWeatherClient
@inject NavigationManager Nav
@inject SemanticSearch Search

@implements IDisposable

<PageTitle>Ai Chat</PageTitle>

<ChatHeader OnNewChat="@ResetConversationAsync" OnLoadDocuments="@LoadDocumentsAsync" />

<ChatMessageList Messages="@messages" InProgressMessage="@currentResponseMessage">
    <NoMessagesContent>
        <div>
            To get started, try asking about these example documents.
        </div>
        <ChatCitation File="Tomislav Wittenberg.md" />
        <_Weather City="Požega" />
    </NoMessagesContent>
</ChatMessageList>

<div class="chat-container">
    <ChatSuggestions OnSelected="@AddUserMessageAsync" @ref="@chatSuggestions" />
    <ChatInput OnSend="@AddUserMessageAsync" @ref="@chatInput" />
    @* <SurveyPrompt /> *@ @* Remove this line to eliminate the template survey message *@
</div>

@code {
    const string SystemPrompt = @"
        You are an assistant who answers questions about information you retrieve.
        Do not answer questions about anything else.
        Only support information based on search results, not based on your existing knowledge.

        Use only simple markdown to format your responses.

        Use the LoadDocuments tool to prepare for searches before answering any questions.

        Use the Search tool to find relevant information. When you do this, end your
        reply with citations in the special XML format:

        <citation filename='string'>exact quote here</citation>

        Always include the citation in your response if there are results.

        The quote must be max 5 words, taken word-for-word from the search result, and is the basis for why the citation is relevant.
        Don't refer to the presence of citations; just emit these tags right at the end, with no surrounding text.

        
        When providing weather information, you must always end your response with the Weather component tag, like this:

        <Weather City=""Put here Name of the City"" />

        Example: <Weather City=""Zagreb"" />      Do not add any text after this tag.
        ";

    int statefulMessageCount;
    readonly ChatOptions chatOptions = new();
    readonly List<ChatMessage> messages = new();
    CancellationTokenSource? currentResponseCancellation;
    ChatMessage? currentResponseMessage;
    ChatInput? chatInput;
    ChatSuggestions? chatSuggestions;

    protected override void OnInitialized()
    {
        statefulMessageCount = 0;
        messages.Add(new(ChatRole.System, SystemPrompt));

        chatOptions.Tools = [
            AIFunctionFactory.Create(LoadDocumentsAsync),
            AIFunctionFactory.Create(SearchAsync),
            // AIFunctionFactory.Create(GeocodeAsync),
            AIFunctionFactory.Create(OpenWeatherClient.GetWeatherAsync)
        ];
    }

    async Task AddUserMessageAsync(ChatMessage userMessage)
    {
        CancelAnyCurrentResponse();

        // Add the user message to the conversation
        messages.Add(userMessage);
        chatSuggestions?.Clear();
        await chatInput!.FocusAsync();

        // Stream and display a new response from the IChatClient
        var responseText = new TextContent("");
        currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);
        currentResponseCancellation = new();
        await foreach (var update in ChatClient.GetStreamingResponseAsync(messages.Skip(statefulMessageCount), chatOptions, currentResponseCancellation.Token))
        {
            messages.AddMessages(update, filter: c => c is not TextContent);
            responseText.Text += update.Text;
            chatOptions.ConversationId = update.ConversationId;
            ChatMessageItem.NotifyChanged(currentResponseMessage);
        }

        // Store the final response in the conversation, and begin getting suggestions
        messages.Add(currentResponseMessage!);
        statefulMessageCount = chatOptions.ConversationId is not null ? messages.Count : 0;
        currentResponseMessage = null;
        chatSuggestions?.Update(messages);
    }

    void CancelAnyCurrentResponse()
    {
        // If a response was cancelled while streaming, include it in the conversation so it's not lost
        if (currentResponseMessage is not null) messages.Add(currentResponseMessage);

        currentResponseCancellation?.Cancel();
        currentResponseMessage = null;
    }

    async Task ResetConversationAsync()
    {
        CancelAnyCurrentResponse();
        messages.Clear();
        messages.Add(new(ChatRole.System, SystemPrompt));
        chatOptions.ConversationId = null;
        statefulMessageCount = 0;
        chatSuggestions?.Clear();
        await chatInput!.FocusAsync();
    }


    #region RAG Functions - Tools for Retrieval-Augmented Generation
    [Description("Loads the documents needed for performing searches. Must be completed before a search can be executed, but only needs to be completed once.")]
    async Task LoadDocumentsAsync()
    {
        await InvokeAsync(StateHasChanged);
        await Search.LoadDocumentsAsync();
    }

    [Description("Searches for information using a phrase or keyword. Relies on documents already being loaded.")]
    async Task<IEnumerable<string>> SearchAsync(
        [Description("The phrase to search for.")] string searchPhrase,
        [Description("If possible, specify the filename to search that file only. If not provided or empty, the search includes all files.")] string? filenameFilter = null)
    {
        await InvokeAsync(StateHasChanged);
        var results = await Search.SearchAsync(searchPhrase, filenameFilter, maxResults: 5);
        return results.Select(result => $"<result filename=\"{result.DocumentId}\">{result.Text}</result>");
    }


    // async Task<IEnumerable<string>> GeocodeAsync([Description("The address or place name to geocode.")] string location)
    async Task<GeocodingResult?> GeocodeAsync([Description("The address or place name to geocode.")] string location)
    {
        using var httpClient = new HttpClient();
        var url = $"https://geocoding-api.open-meteo.com/v1/search?name={Uri.EscapeDataString(location)}&count=1";
        var response = await httpClient.GetFromJsonAsync<GeocodingResponse>(url);

        var resultText = response?.Results.FirstOrDefault() != null
            ? $"Location: {response.Results[0].Name}, Latitude: {response.Results[0].Latitude}, Longitude: {response.Results[0].Longitude}"
            : "Could not find the specified location.";

        Console.WriteLine("GeocodeAsync response: " + resultText);

        return response!.Results.FirstOrDefault();
        // if (response?.Results is null || response.Results.Length == 0)
        // {
        //     return ["Could not find the specified location."];
        // }
        // var result = response.Results[0];
        // return [$"Location: {result.Name}, Latitude: {result.Latitude}, Longitude: {result.Longitude}"];
    }

    record GeocodingResponse(GeocodingResult[] Results);
    record GeocodingResult(string Name, float Latitude, float Longitude);


    // async Task<IEnumerable<string>> GetWeatherAsync(
    //     [Description("The latitude of the location to get the weather for.")] float latitude,
    //     [Description("The longitude of the location to get the weather for.")] float longitude)
    // {
    //     using var httpClient = new HttpClient();
    //     var url = $"https://api.open-meteo.com/v1/forecast?latitude={latitude}&longitude={longitude}&daily=temperature_2m_max&timezone=auto";
    //     var response = await httpClient.GetFromJsonAsync<WeatherResponse>(url);
    //     if (response?.Daily?.Temperature_2m_Max is null)
    //     {
    //         return ["Could not retrieve weather data."];
    //     }

    //     return response.Daily.Temperature_2m_Max.Select((temp, index) => $"Day {index + 1}: {temp}°C");
    // }

    // record WeatherResponse(WeatherReports Daily);
    // record WeatherReports(float[] Temperature_2m_Max);
    #endregion

    public void Dispose() => currentResponseCancellation?.Cancel();
}